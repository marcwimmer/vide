extends python

snippet unittest "V11"
import arrow
import os
import pprint
import logging
import time
import uuid
from datetime import datetime, timedelta
from unittest import skipIf
from odoo import api
from odoo import fields
from odoo.addons.unit_test_complex import tests
from odoo.tests import common
from odoo.tools import DEFAULT_SERVER_DATETIME_FORMAT
from odoo.tools import DEFAULT_SERVER_DATE_FORMAT
from odoo.exceptions import UserError, RedirectWarning, ValidationError, AccessError


class $1(common.TransactionCase):

	def setUp(self):
		super().setUp()

    @skipIf(os.getenv("ODOO_TESTS", "0") == "0", "")
    def test_$2(self):
        """ $3  """
        env = api.Environment(self.env.cr, self.capa_manager_marketing.id, {})
        self.assertTrue(latest_line.after_confirmed)
endsnippet

snippet translate_selection "<V9"
dict(self.pool.get(${1:model}).fields_get(cr, uid, allfields=[${2:field}], context=context)[$2]['selection']).get(${3:value}, $3)
endsnippet
snippet translate_selection ">=V9"
dict(self.fields_get([${1:field}])[$1]['selection']).get(${2:value}, ${3:default_value})
endsnippet

snippet superuser
from openerp import SUPERUSER_ID
endsnippet

snippet DATETIME
from openerp.tools import DEFAULT_SERVER_DATETIME_FORMAT
from openerp.tools import DEFAULT_SERVER_DATE_FORMAT
endsnippet

snippet sb
self.browse(cr, uid, ${1:id}, context=context)
endsnippet

snippet sr
self.read(cr, uid, ${1:id}, [${2:fields}]context=context)
endsnippet

snippet imp_
from tools.translate import _
endsnippet

snippet spg
self.pool["$1"]$0
endsnippet

snippet def
def ${1:name}(self, cr, uid, ids, context=None):
	if isinstance(ids, (int, long)):
		ids = [ids]
	${0}
	return True
endsnippet 

snippet model_id_get
res_id = self.pool['ir.model.data'].get_object_reference(cr, uid, "${1:module}", "${2:second_part}")[1]
endsnippet

snippet model_id_get "V8"
env.ref('....')
${1:self.env['ir.model.data'].xmlid_to_res_id('$2')}
${3:self.env['ir.model.data'].xmlid_to_object('$4')}
endsnippet

snippet utf8
# -*- coding: utf-8 -*-
endsnippet

snippet date2str
$1.strftime("%Y-%m-%d %H:%M:%S")
endsnippet

snippet now "now as datetime NOT string"
now = datetime.utcnow().strftime("%Y-%m-%d %H:%M:%S")
endsnippet

snippet now "Fields.Datetime.now()"
fields.Datetime.now()
endsnippet

snippet today 
fields.Date.today()
endsnippet

snippet str2date "fields.DateTime"
fields.Datetime.from_string($1)
endsnippet

snippet str2date "fields.Date"
fields.Date.from_string($1)
endsnippet

snippet str2date "strptime"
datetime.strptime($1, "%Y-%m-%d %H:%M:%S")
endsnippet

snippet c=c
context=context
endsnippet

snippet mt "Make tuple"
if isinstance(${1:id}, (int, long)):
	$1 = [$1]
$0
endsnippet

snippet ex 
raise osv.except_osv(
	_('${1:errorhappened}'), 
	_('${2:detailed}'))
endsnippet

snippet bn
isinstance(${1:expression}, osv.orm.browse_null)
endsnippet

snippet st
from pudb import set_trace
set_trace()
endsnippet

snippet traceback
import traceback
msg = traceback.format_exc()
endsnippet

snippet lgdebug
logger.debug("$0")
endsnippet

snippet lgerror
logger.error("$0")
endsnippet

snippet dbname_from_thread
db_name = getattr(threading.currentThread(), 'dbname', None)
endsnippet

snippet mod "OpenERP Module"
{
    "name" : "${1:module_name}",
    "description": "${2:description}",
    "version" : "1.0",
    "author" : "${3:user}",
    "category" : "${4:category}",
    "depends" : ["base"],
    "demo_xml" : [ ],
    "update_xml" : [
        #"subdir/file.xml",
    ],
    "test": [],
    "installable": True,
    "active": False,
    "web": False,
    "js": [],
    "css": [],
    "qweb": [],
}
endsnippet


snippet onchange
def onchange_$1(self, cr, uid, ids, ${1:field1}, context=None):
	return {
		"warning": {'title': '...', 'message': '...'},
		"value": {
			"any_field_1": any_value_you_want
		}
		"domain": {
			"field": [],
		}
	}

    @api.multi
    def onchange(self, values, field_name, field_onchange):
        result = super(PurchaseOrderLine, self).onchange(values, field_name, field_onchange)
        if isinstance(result, dict) and isinstance(field_name, str):  # single field change
            if result.get('value', False):
                if result['value'].get('date_planned', False):
                    result['value'].pop('date_planned')

        return result
endsnippet

snippet model "memory class base on sql view"
from odoo import models, api, tools, _

class ${1/\./_/g}(models.Model):
	_name = "${1:model_name}
	_auto = False
	"${3:field_name}": fields.char("${4:field_title}", readonly=True,size=100)

    @api.model_cr
	def init(self):
		tools.drop_view_if_exists(self._cr, '${1/\./\_/g}}')
		self._cr.execute("""
				CREATE or REPLACE view $5 as (
					SELECT
						res_partner.id,
						res_partner.name as name
					FROM
						res_partner
					WHERE
						res_partner.id > 10
				)
		""")
endsnippet


snippet crud "Overwrite create, update, delete in osv"
def create(self, cr, uid, values, context=None):
	result = super($1, self).create(cr, uid, values, context)
	return result

def write(self, cr, uid, ids, values, context=None):
	result = super($1, self).write(cr, uid, ids, values, context)
	return result

def unlink(self, cr, uid, ids, context=None):
	result = super($1, self).unlink(cr, uid, ids, context)
	return result
endsnippet

snippet crud "V8"
@api.model
def create(self, vals):
	result = super($1, self).create(vals)
	return result

@api.multi
def write(self, vals):
	result = super($1, self).write(vals)
	return result

@api.multi
def unlink(self):
	result = super($1, self).unlink()
	return result
endsnippet

snippet crud "V11"
def create(self, vals):
	result = super().create(vals)
	return result

def write(self, vals):
	result = super().write(vals)
	return result

def unlink(self):
	result = super().unlink()
	return result
endsnippet

snippet fvg "V9 Fields View Get"
@api.model
def fields_view_get(self, view_id=None, view_type='form', toolbar=False, submenu=False):
	result = super(BaseNextActivity, self).fields_view_get(view_id=view_id, view_type=view_type, toolbar=toolbar, submenu=submenu)
	if view_type == 'form':
		doc = etree.XML(result['arch'])
		node = doc.xpath("//group[@name='next_activity_group']")
		if node:
			node = node[0]
			xml = """
			  <group col="2" string="Next Activitiy">
				<field name="next_activity_id"/>
				<field name="title_action"/>
				<field name="date_action"/>
				<div attrs="{'invisible': [('next_activity_id', '=', False)]}">
				  <button name="log_next_activity_done" string="Done" type="object" class="btn-link oe_read_only" attrs="{'invisible': [('next_activity_id', '=', False)]}"/>
				  <button name="cancel_next_activity" string="Cancel" type="object" class="btn-link oe-oe_read_only" attrs="{'invisible': [('next_activity_id', '=', False)]}"/>
				</div>
			  </group>
			"""
			node.tag = 'group'
			node.attrib['string'] = 'Next Activity'
			for n in etree.XML(xml).xpath("*"):
				node.append(n)

			result['arch'], new_fields = self.env['ir.ui.view'].postprocess_and_fields(self._name, doc, view_id)

			# nur neue Felder uebernehmen; ansonsten gehen definierte unter views verloren (werden von form nach fields ausgelagert)
			for k, v in new_fields.items():
				if k not in result['fields']:
					result['fields'][k] = v
	return result
endsnippet

snippet fvg "V7 Fields View Get"
def fields_view_get(self, cr, uid, view_id=None, view_type='form', context={}, toolbar=False):
	result = super($1, self).fields_view_get(cr, uid, view_id, view_type, context=context, toolbar=toolbar)
	###your modification in the view
	###result['fields'] will give you the fields. modify it if needed
	###result['arch'] will give you the xml architecture. modify it if needed
	"""
	from openerp.osv.orm import setup_modifiers
	from lxml import etree
	doc = etree.XML(result['arch'])
	for node in doc.xpath("//field[@name='project_id']"):
		# do some computations....
		node.set('domain', YOUR DOMAIN)

		# invisible, attrs (modifiers) setzen; modifiers muss per setup_modifiers uebertragen werden
		# ich hab z.B. dynamisch einen Knopf hinzugefuegt; dann noch in result['fields'] ein dict anlegen:
		# result['fields'].setdefault(fieldname, {})
		anynode.set("readonly", "1")

		#insert a new field:
			from openerp.osv.fields import field_to_dict
			result['fields']['fieldname'] = field_to_dict(self, cr, uid, self._columns['fieldname'], context=context)
		#for new and updated fields:
		setup_modifiers(anynode, result['fields']['fieldname'])
	result['arch'] = etree.tostring(doc)
	"""
	return result
endsnippet

snippet fields "fields.reference: Method for delivering models as content of fields.reference; MUST BE OUTSIDE OF CLASS!"
def _get_models(self, cr, uid, context=None):
	ir_model = self.pool["ir.model"]
	ids = ir_model.search(cr, uid, [('model', 'in', ('${1:model1}'))])
	res = ir_model.read(cr, uid, ids, ['model', 'name'], context=context)
	return [(r['model'], r['name']) for r in res]
#'ref': fields.reference(string="Referenced Item", selection=_get_models, size=256),
endsnippet

snippet fields "fields.selection: Method for delivering selection contents"
'${1:field_name}': fields.selection(lambda *params: ${2:your_func}, string="${3:a_string}"),
endsnippet

snippet fields "fields.function: method read value"
def ${1:name}(self, cr, uid, ids, field_name, args, context=None):
	result = {}
	for o in self.read(cr, uid, ids, [], context=context):
		result[o['id']] = $0
	return result
endsnippet

snippet fields "fields.function: method as base for selectable values"
#put somewhere: STATES = [('unstable', 'Unstable')]
'${1:field_name}': fields.function(_get_state_id, type='selection', selection=STATES, readonly=False, method=True),
endsnippet

snippet fields "fields.function: store method or change depending on"
'${1:field_name}': fields.function(${2:method}, type="${3:type}", method=True, string="${4:string}", size=256,
													store={
															'${5:model}': (
																	lambda self, cr, uid, ids, context=None: ids,
																	['${6:changed_field1}', '${7:changed_field2}'],
																	5 #priority
															)
													}), 
endsnippet

snippet fields "fields.function: inverse write"
#fields.function(... fnct_inv=$1)
def ${1:field_name}(self, cr, uid, ids, field_name, field_value, fnct_inv_arg, context=None):
	if isinstance(ids, (int, long)): 
		ids = [ids]
	for id in ids:
		self.write(cr, uid, [id], {field_name: field_value}, context=context)
	return True
endsnippet

snippet fields "fields.function: fnct_search parameter in field-definition"
fnct_search= lambda self, cr, uid, obj, name, args, context=None: self.your_cool_search_function(cr, uid, obj, name, args, context=context)
endsnippet

snippet fields "fields.function: fnct_search def"
def ${1:name}(self, cr, uid, obj, name, args, context=None):
	${0}
	found_ids = []
	return [('id', 'in', found_ids)]
endsnippet

snippet Fields "selection add"
fields.Selection(selection_add=[('$1', '$2')])
endsnippet

snippet Fields "compute"
@api.depends('sender')
@api.one
def ${1:name}(self):
	self.${2:fieldname} = ${0}
endsnippet

snippet Fields "search"
def ${1:name}(self, operator, value):
	${0}
	found_ids = []
	return [domain]
endsnippet

snippet Fields "inverse"
${2:@api.depends("${3:name}")}
@api.one
def ${1:name}(self):
endsnippet

snippet "fields.function: state store field"
'${1:field_name}':
	fields.function(
		_${2:get_method}, method=True,
		string='${3:string}',
		type='selection',
		selection=${4:variable or list},
		store={
			'${5:model}': (
				lambda self, cr, uid, ids, context=None: ids,
				['${6:changed_field1}'], 5 #sequence
			)
	}),
endsnippet

snippet "fields.function: selection"
'${1:name}': fields.function(${2:method}, type='selection', selection=${3:array}, method=True, string="${4:name}", translate=True),
endsnippet

snippet df "Block"
_defaults = {
	$1
}
endsnippet

snippet df "current date V7"
'${1:field_name}': lambda *a: datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
endsnippet

snippet df "current date V9"
default=fields.Date.context_today
endsnippet

snippet df "picks an entity-instance and sets it"
'${1:field_name}':lambda self, cr, uid, context:self.pool['${2:entity_to_search}'].read(cr, uid, uid, ['${3:field_value_to_take}'], context )['$3'],
endsnippet

snippet df "a constant"
'${1:field_name}': lambda *a: ${2:field_value},
endsnippet

snippet df "current user"
'${1:field_name}': lambda self, cr, uid, context: uid,
endsnippet

snippet sqlc "Block"
_sql_constraints = [
	$1
]
endsnippet

snippet constraints "Constraints V9"
@api.multi
def $1(self):
	for rec in self:
		$0
	return True

_constraints = [
	(${1:name}, '${2:error-message}', [${3:fields}]),
]
endsnippet

snippet sqlc "CHECK for value"
('${1:field_name}_value', "CHECK( ($1='value' and $1 is not null) or (2=2))", _("Please select %S") % '${2:field_title}'"),
endsnippet

snippet sqlc "UNIQUE single field"
('${1:field_name}_unique', "unique($1)", _("Only one unique entry allowed.")),
endsnippet

snippet sqlc "UNIQUE field-combination"
('${1:field_name}_${2:field_name2}_unique', "unique($1, $2)", _("Only one unique entry allowed for %s") % '${3:description}'),
endsnippet

snippet constraints "Block"
_constraints = [
	$0
]
endsnippet

snippet constraints "Constraint Field with evaluation function"
def ${1:const_function}(self, cr, uid, ids, context=None):
	for id in ids:
		if not good Then:
			return False
	return True
($1, '${2:Here you describe error to user}', ['field1', 'field2']),
endsnippet

snippet cronjob "a scheduled method callable by cron jobs"
def ${1:name}(self, cr, uid, ids=False, context=None):
	${2:#fields}
endsnippet


snippet window_close "Close Window"
{'type': 'ir.actions.act_window_close'}
endsnippet 

snippet open_window "Open Window with options as comments"
return {
	'view_type': 'form',
	'res_model': self._name,
	#'res_id': ,
	#'domain': [],
	#'views': [(obj.get_formview_id(), 'form'), (False, 'tree')],
	#'views': [(False, 'tree'), (False, 'form')],
	'type': 'ir.actions.act_window',
	'flags': {'form': {
		'action_buttons': True,  // to work in odoo 11 insert empty <footer /> in form (tested 18.05.2018)
		#'initial_mode': 'edit'/'view'
		#'footer_to_buttons': False,
		#'not_interactiable_on_create': False,
		#'disable_autofocus': False,
		#'headless': False,  9.0 and others?
	}},
	'options': {
		# needs module web_extended_actions
		'hide_breadcrumb': True,
		'replace_breadcrumb': True,
		'clear_breadcrumbs': True,
	},
	'target': '${7:current}',
}
endsnippet

snippet view "Create New Entity"
res = self.pool['ir.actions.act_window'].for_xml_id(cr, uid, '${1:module}', '${2:action_id}', context)
res['context'] = {
	'default_${3:field_name}': ${4:any_value},
}
return res
endsnippet

snippet report "Code to open a report programmatically V7"
report_service = 'report.' + ${1:report_name}
from openerp import netsvc
service = netsvc.LocalService(report_service)
(result_binary, format) = service.create(cr, uid, [${2:record_id}], {'model': self._name}, context=context)
endsnippet

snippet report "Code to open a report programmatically V9"
result_binary, format = self.env['ir.actions.report.xml'].render_report(instance.ids, '${1:name_without_report}', data={})
endsnippet

snippet report "Code to open a report programmatically V11"
result_binary, format = self.env.ref("$1").render(${2:instance or instance.ids}, data={})
endsnippet

snippet report "Code to return a report as an action"
data = {'ids': context.get('active_ids', [])}
res = self.read(cr, uid, ids, context=context)
res = res and res[0] or {}
data['form'] = res
return {
	'type': 'ir.actions.report.xml',
	'report_name': '${2:report_name_without_report_dot_starting}',
	'datas': data,
	'context': context or {} #provide active_ids when called from server action !
}
endsnippet

snippet report "Code to return a report as an action V9 - on button click"
return self.env['report'].get_action(${1:instance_of_your_object}, '${2:report_name_without_starting_report}')

#with ids:
context = dict(dict(self.env.context) or {}, active_ids=ids)
return self.pool['report'].get_action(self.env.cr, self.env.user.id, instance.ids, 'report_name', context=context)
endsnippet

snippet report "Code to return a report as an action V11"
return self.env.ref("$1").report_action(${2:instances or instance.ids})
endsnippet

snippet wiz "Code to open next window of a wizard"
def ${1:finish1}(self, cr, uid, id, context=None):
	"""
	"""
	id = long(id[0]) #since i got a string here, i always make this sure :)
	me = self.browse(cr, uid, id, context)
	#get the next page
	_, view_id = self.pool['ir.model.data'].get_object_reference(cr, uid, "${2:module}", "${3:view_id_page}")

	return {
		'name': 'State of import}',
		'context': context,
		'view_type': 'form',
		'view_mode': 'form',
		'res_model': self._name,
		'res_id': id,
		'view_id': False,
		'views': [(view_id, 'form')],
		'type': 'ir.actions.act_window',
		'target': 'new',
		'nodestroy': False,
	} 

	#minimum:
	return {
		'view_type': 'form',
		'view_mode': 'form',
		'res_model': self._name,
		'type': 'ir.actions.act_window',
		'target': 'new',
		'context': context,
		'nodestroy': True,
	}
endsnippet


snippet closewindow "Code close window"
return {'type': 'ir.actions.act_window_close'}
endsnippet

snippet wiz "Set initial values for the wizard page"
def view_init(self, cr, uid, fields, context=None):
	context["default_${1:field_name}"] = ${2:any_value}
	pass
endsnippet



snippet report "Report Parser Class Webkit/Default"
import time
from openerp.report import report_sxw
from openerp.osv import osv

class ${1:class_name}(report_sxw.rml_parse):
	def __init__(self, cr, uid, name, context):
		super($1, self).__init__(cr, uid, name, context=context)

		users = self.pool["res.users"]
		lang = users.browse(cr, 1, uid, context=context).lang
		self.localcontext.update({
			'time': time,
			'cr': cr,
			'uid': uid,
			'lang': lang,
		})

	def set_context(self, objs, data, ids, report_type):
		super($1, self).set_context(objs, data, ids, report_type)

		cr = self.localcontext['cr']
		uid = self.localcontext['uid']

		self.localcontext.update({ 'lines': lines })

report_sxw.report_sxw(
	'report.${2:report_name_as_in_xml}',
	'${3:model}',
	parser=$1
)
endsnippet

snippet report "Report Parser Class Excel"
import time
from report import report_sxw
from openerp.osv import osv

class ${1:class_name}(report_sxw.rml_parse):
	def excel(self, cr, uid, ids, context=None):
		result = { }

		result['records'] = self.pool.get("res.partner").read(cr, uid, self.pool.get("res.partner").search(cr, uid, []), ['name'])
		result['columns'] = ['name']
		result['sheet_name'] = 'partners'
		return result

report_sxw.report_sxw(
	'report.${2:report_name_as_in_xml}',
	'${3:model}',
	parser=$1
)
endsnippet

snippet report "Parser Class qweb-pdf V9"
# -*- coding: utf-8 -*-

from openerp import api, fields, models

class $1(models.AbstractModel):
    _name = 'report.${2:name}'

    @api.multi
    def render_html(self, data):
        docargs = {
            'doc_ids': self.ids,
            'doc_model': 'res.partner',
            'docs': self.env['res.partner'].browse(self.ids),
            'Date': fields.date.today(),
            'order_number': '12345',
        }
        return self.env['report'].render('${3:template_id}', values=docargs)
endsnippet


snippet test "WebBrowser Test"
import datetime
from selenium import webdriver
from selenium import common
from selenium import selenium
from selenium.common.exceptions import NoSuchElementException
from selenium.webdriver.common.keys import Keys
import inspect, os, xmlrpc, time, subprocess, sys 
import time
import sys
timeout = 30

db = "${1:db}"
host = "http://localhost:8069"
user = "${2:admin}"
password = "${3:password}"

browser = webdriver.Firefox() # Get local session of firefox

def exe(*params):
	socket_obj = xmlrpclib.client.ServerProxy('%s/xmlrpc/object'%(host))
	return socket_obj.execute(db, 1, pwd, *params)


def browser_find_element_by_xpath(xpath):
	start = datetime.datetime.now()
	while (datetime.datetime.now() - start).seconds < timeout:
		try:
			el = browser.find_element_by_xpath(xpath)
			time.sleep(0.3)
			return el
		except:
			pass

browser.maximize_window()

#login 6.1
	browser.get("%s/web/webclient/login?login=%s&db=%s&key=%s" % (host, user, db, password))
#login 6.0
	browser.get("%s/openerp/login?user=%s&db=%s&password=%s&style=ajax_small&tg_format=json" % (host, user, db, password))
	time.sleep(1)
	assert "OpenERP" in browser.title

#demo test:
	browser.find_element_by_xpath("//select/option[@value='%s']" % db).click()
#browser_find_element_by_xpath("//button[@title='Designer']").click()
#browser.click("css = td.oe - field - cell.oe - button > button[type = \"button\"]")
#values = exe("res.partner", "read", [100], ["name"])
#assert values["name"] == "test"
	browser.close()
endsnippet

snippet xmlrpc "Script to Access odoo via xmlrpc"
import inspect
import os
import xmlrpc
import time
import subprocess
import sys

host = "http://localhost:8069"
username = "admin"
pwd = "${1:password}"
db = "${2:db}"

def login(username, password):
	socket_obj = xmlrpclib.client.ServerProxy('%s/xmlrpc/common' % (host))
	uid = socket_obj.login(db, username, password)
	return uid
uid = login(username, pwd)

def exe(*params):
	global uid
	socket_obj = xmlrpclib.client.ServerProxy('%s/xmlrpc/object' % (host))
	return socket_obj.execute(db, uid, pwd, *params)

values = exe("res.partner", "read", [100], ["name"])
endsnippet


snippet controller "Web Controller Body"
import openerp

class ${1:class_name}(openerp.addons.web.http.Controller):
	_cp_path = '/mg_goldprice'

	@openerp.addons.web.http.jsonrequest
	def hello_world(self, request, ean):
		"""
		A product has been scanned with success
		"""
		return "test" 


endsnippet
snippet controller "V7"
from openerp.addons.web import http
openerpweb = http

class ${1:class_name}(openerpweb.Controller):
	_cp_path = "${2:path}"

	@openerpweb.jsonrequest
	def get_label(self, req):
		return "Hello World!"

endsnippet

snippet controller "V8"
# -*- coding: utf-8 -*-
from openerp import http
from openerp.http import request
from openerp.addons.web.controllers.main import content_disposition


class Controller(http.Controller):
	@http.route('/downloads/<int:id>', auth='public', website=True)
	def index(self, id):
		p = request.registry.get("product.product").browse(
			request.cr, request.uid, id)

		return http.request.render("website_download.index", {
			'product': p,
		})

endsnippet

snippet controller "V11"
from odoo import http
from odoo.http import request

class $1(http.Controller):

    @http.route('${2:/some_url}', auth='${3:public}${4:user}', ${5:type="json"})
    def handler(self, **post):
        return stuff()

endsnippet

snippet controller "Method"
@openerpweb.jsonrequest
def ${1:name}(self, req, ${2:params}):
	${0}

endsnippet

snippet send_mail
def sendmail(subject, body):
	from smtplib import SMTP 
	from email.mime.text import MIMEText as text


	fromaddr = 'mygoldobserver@itewimmer.de'  
	toaddrs  = 'marc@itewimmer.de'  

	m = text(body)
	m["Subject"] = subject
	m["From"] = fromaddr
	m["To"] = toaddrs

	# Credentials (if needed)  
	username = 'v05092101p0019'  
	password = 'openerprocks'  

	# The actual mail send  
	server = SMTP('smtp.mail.sasg.de:587')  
	server.starttls()  
	server.login(username,password)  
	server.sendmail(fromaddr, toaddrs, m.as_string())  
	server.quit()  

sendmail("this is a subject", "and the body")
endsnippet

snippet fb "Fields Bool"
'$1': fields.boolean('${2:string}'),
endsnippet

snippet fB "Fields Bool"
$1 = fields.Boolean('${1:string}')
endsnippet

snippet fc "Fields Character"
'$1': fields.char('${2:string}', size=${3:128}),
endsnippet

snippet fC "Fields Character"
$1 = fields.Char('${2:string}')
endsnippet

snippet fF "Fields Float"
'$1' =  fields.Float('${2:string}', digits=(16, 4))
endsnippet

snippet fF "dp precision"
from odoo.addons import decimal_precision as dp
import openerp.addons.decimal_precision as dp
'$1' =  fields.Float('${2:string}', digits=dp.get_precision('${3:Unit of Measure}'))
endsnippet

snippet fi "Fields Integer"
'${1}': fields.integer('${2:string}'),
endsnippet

snippet fs "Fields Selection"
'${1}': fields.selection([('${2:v1}', '${3:v2}'), ], '${4:string}'),
endsnippet

snippet stup "String Tuple"
('${1:v1}', '${2:v2}')
endsnippet


snippet fdt "Fields DateTime"
'${1}': fields.datetime('${2:string}'),
endsnippet

snippet fd "Fields Date"
'${1}': fields.date('${2:string}'),
endsnippet

snippet ft "Fields Text"
'${1}': fields.text('${2:string}'),
endsnippet

snippet fM2m "Fields many2many"
${1}_ids = fields.Many2many('${2:model}', string='${3}')
endsnippet

snippet fm2m "Fields many2many"
'${1}_ids': fields.many2many('${2:model}', string='${3}'),
endsnippet

snippet fo2m "Fields one2many"
'${1}_ids': fields.one2many('${2:model}', '${3}_id',  string='${4}'),
endsnippet

snippet fO2m "Fields one2many"
${1}_ids = fields.One2many('${2:model}', '${3}_id',  string='${4}')
endsnippet

snippet fm2o "Fields many2one"
'${1}_id': fields.many2one('${2:model}', string='${3}'),
endsnippet

snippet fM2o "Fields many2one"
${1}_id = fields.Many2one('${2:model}', string='${3}')
endsnippet

snippet fr "Fields Reference"
'${1}': fields.reference(string='${2}', selection = [(${3},${4}), (${5}, ${6})], size=128),
endsnippet 

snippet fstate "Fields state"
'state': fields.selection([
			('draft', 'Draft'), 
			('done', 'Done'),
		], string='State'),
endsnippet

snippet ALL
import os
import glob
__all__ = sorted([os.path.basename(f)[:-3] for f in glob.glob(os.path.dirname(__file__) + "/*.py")])
endsnippet

snippet timezone
#from outlookstormer version 7.0
def convert_user_to_utc(self, date, context):
	if not date:
		return False
	if isinstance(date, (str, unicode)):
		date = datetime.strptime(date, "%Y-%m-%d %H:%M:%S")
	utc = pytz.timezone('UTC')
	context_tz = pytz.timezone(context['tz'])
	tz_timestamp = context_tz.localize(date, is_dst=True)
	date = tz_timestamp.astimezone(utc)
	return date

def convert_utc_to_user(self, date, context):
	if not date:
		return False
	if isinstance(date, (str, unicode)):
		date = datetime.strptime(date, "%Y-%m-%d %H:%M:%S")
	utc = pytz.timezone('UTC')
	context_tz = pytz.timezone(context['tz'])
	utc_timestamp = utc.localize(date, is_dst=False)  # UTC = no DST
	return utc_timestamp.astimezone(context_tz)
endsnippet

snippet pretty
import pprint
pp = pprint.PrettyPrinter()
pp.pprint(SETS)
endsnippet

snippet seq "by xmlid"
self.env.['$1'].next_by_id()
endsnippet

snippet seq "by xmlid v9"
seq = self.env['ir.model.data'].xmlid_to_object("mail_report_wall.documentseq").next_by_id()
endsnippet

snippet seq "by code"
self.pool['ir.sequence'].next_by_code(cr, 1, ${1:code}, {})
endsnippet

snippet '
'${1}'$0
endsnippet

snippet {
{'${1}': $0 }

endsnippet


snippet Import

def Import(self, cr, uid, context=None, debug=False):

	#NAVI7
	conn = self.get_conn('navi${1:57}', as_dict=True)
	try:
		mssql = conn.cursor()

		cache_items = {}

		cols = [${2:columns}]
		mssql.execute("select distinct %s from [NAV7_PROD$Item] "%",".join(["[%s]"%x for x in cols]))
		for item in mssql.fetchall():
			item = self.lowifydict(item)
			item['name'] = '%s %s' % (item['no_'], item['description'])
			del item['description']
			item['nav_prod_number'] = item['no_']
			del item['no_']

			item['net_weight'] = item['net weight']
			item['gross_weight'] = item['gross weight']
			item['sale_item_number'] = item['sales item no_']


			cache_items[item["nav_prod_number"]] = self.merge(cr, uid, self._name, item, "nav_prod_number", context=context)
			cr.commit()

	finally:
		conn.close()

endsnippet

snippet name_search "V7"
def name_search(self, cr, user, name='', args=None, operator='ilike', context=None, limit=100):
	if not args:
		args = []
	if name:
		ids = self.search(cr, user, [('default_code','=',name)]+ args, limit=limit, context=context)
		if not ids:
			ids = self.search(cr, user, [('ean13','=',name)]+ args, limit=limit, context=context)
		if not ids:
			# Do not merge the 2 next lines into one single search, SQL search performance would be abysmal
			# on a database with thousands of matching products, due to the huge merge+unique needed for the
			# OR operator (and given the fact that the 'name' lookup results come from the ir.translation table
			# Performing a quick memory merge of ids in Python will give much better performance
			ids = set()
			ids.update(self.search(cr, user, args + [('default_code',operator,name)], limit=limit, context=context))
			if not limit or len(ids) < limit:
				# we may underrun the limit because of dupes in the results, that's fine
				ids.update(self.search(cr, user, args + [('name',operator,name)], limit=(limit and (limit-len(ids)) or False) , context=context))
			ids = list(ids)
		if not ids:
			ptrn = re.compile('(\[(.*?)\])')
			res = ptrn.search(name)
			if res:
				ids = self.search(cr, user, [('default_code','=', res.group(2))] + args, limit=limit, context=context)
	else:
		ids = self.search(cr, user, args, limit=limit, context=context)
	result = self.name_get(cr, user, ids, context=context)
	return result
endsnippet

snippet name_search "V9"
@api.model
def name_search(self, name='', args=None, operator='ilike', limit=100):
    result = super($1, self).name_search(name=name, args=args, operator=operator, limit=limit)
	return result
endsnippet

snippet name_get "V7"
def name_get(self, cr, uid, ids, context=None):
	context = context or {}
	if isinstance(ids, (int, long)):
		ids = [ids]
	res = []
	for record in self.browse(cr, uid, ids, context=context):
		name = record.name
		if record.parent_id and not record.is_company:
			name = name
		if context.get('show_address'):
			name = name + "\n" + self._display_address(cr, uid, record, without_company=True, context=context)
			name = name.replace('\n\n','\n')
			name = name.replace('\n\n','\n')
		if context.get('show_email') and record.email:
			name = "%s <%s>" % (name, record.email)
		res.append((record.id, name))
	return res
endsnippet

snippet name_get "V9"
@api.multi
def name_get(self):
	res = super($1, self).name_get()
	return res
endsnippet

snippet default_get "V7"
def default_get(self, cr, uid, fields, context=None):
	res = super(${1:klass}, self).default_get(cr, uid, fields, context=context)

	res['${2:fieldname}'] = ${3:fieldvalue}
	return res
endsnippet

snippet default_get "V8"
@api.model
def default_get(self, fields):
	res = super($1, self).default_get(fields)
	data = self.trans_rec_get()
	if 'trans_nbr' in fields:
		res.update({'trans_nbr': data['trans_nbr']})
	return res
endsnippet

snippet default_get "V11"
def default_get(self, fields):
	res = super($1, self).default_get(fields)
	return res
endsnippet

snippet track "track_visibility"
track_visibility="${1:onchange}${2:always}"
endsnippet

snippet track "full track depending on state and message type"
_track = {
	'${1:field}': {
		'${2:message_id with module before}: lambda self, cr, uid, obj, ctx=None: ${3:condition},
	}
}

# sample:
_track = {
	'state': {
		'project.mt_task_new': lambda self, cr, uid, obj, ctx=None: obj['state'] in ['new', 'draft'],
		'project.mt_task_started': lambda self, cr, uid, obj, ctx=None: obj['state'] == 'open',
		'project.mt_task_closed': lambda self, cr, uid, obj, ctx=None: obj['state'] == 'done',
	},
	'stage_id': {
		'project.mt_task_stage': lambda self, cr, uid, obj, ctx=None: obj['state'] not in ['new', 'draft', 'done', 'open'],
	},
	'kanban_state': {  # kanban state: tracked, but only block subtype
		'project.mt_task_blocked': lambda self, cr, uid, obj, ctx=None: obj['kanban_state'] == 'blocked',
	},
}

<record id="mt_rfq_confirmed" model="mail.message.subtype">
    <field name="name">RFQ Confirmed</field>
    <field name="default" eval="False" />
	<field name="res_model">purchase.order</field>
</record>

endsnippet

snippet _track
@api.multi
def _track_subtype(self, init_values):
	if self.project_id and any(x.code == "CM" for x in self.project_id.infogroup_ids):
		if 'stage_id' in init_values:
			if self.stage_id.state == 'archiving':
				return 'heine_capa.subtype_archiving'
			if self.stage_id.state == 'done':
				return 'heine_capa.subtype_done'
			return 'heine_capa.subtype_state_changes'
	return super(Task, self)._track_subtype(init_values)
endsnippet

snippet m2m

+ For a many2many field, a list of tuples is expected.
	Here is the list of tuple that are accepted, with the corresponding semantics ::

	(0, 0,  { values })    link to a new record that needs to be created with the given values dictionary
	(1, ID, { values })    update the linked record with id = ID (write *values* on it)
	(2, ID)                remove and delete the linked record with id = ID (calls unlink on ID, that will delete the object completely, and the link to it as well)
	(3, ID)                cut the link to the linked record with id = ID (delete the relationship between the two objects but does not delete the target object itself)
	(4, ID)                link to existing record with id = ID (adds a relationship)
	(5)                    unlink all (like using (3,ID) for all linked records)
	(6, 0, [IDs])          replace the list of linked IDs (like using (5) then (4,ID) for each ID in the list of IDs)

	Example:
		[(6, 0, [8, 5, 6, 4])] sets the many2many to ids [8, 5, 6, 4]

+ For a one2many field, a lits of tuples is expected.
	Here is the list of tuple that are accepted, with the corresponding semantics ::

	(0, 0,  { values })    link to a new record that needs to be created with the given values dictionary
	(1, ID, { values })    update the linked record with id = ID (write *values* on it)
	(2, ID)                remove and delete the linked record with id = ID (calls unlink on ID, that will delete the object completely, and the link to it as well)

	Example:
		[(0, 0, {'field_name':field_value_record1, ...}), (0, 0, {'field_name':field_value_record2, ...})]
endsnippet


snippet needaction "Need Action (small menu counter on the left)"
def _needaction_domain_get(self, cr, uid, context=None):
	""" Returns the domain to filter records that require an action
		:return: domain or False is no action
	"""
	return False
endsnippet

snippet default_encoding
import sys
reload(sys)
sys.setdefaultencoding('utf-8')
#s = codecs.decode(s, 'unicode_escape')
endsnippet

snippet mtrue
method=True
endsnippet


snippet compute_qty
uom_unit_id = self.pool['ir.model.data'].get_object_reference(cr, uid, "product", "product_uom_unit")[1]
qty = self.pool["product.uom"]._compute_qty(cr, uid, ${1:from_uom_id}, ${2:qty}, ${3:to_uom_id})
endsnippet



snippet retry
def retry(f, maxtries=10, wait=2):
	tried = 0
	while True:
		try:
			result = f()
			return result
		except Exception, e:
			tried += 1
			if tried > maxtries:
				logger.exception(e)
				raise
			logger.debug('retrying...')
			import time
			time.sleep(wait)
endsnippet

snippet subprocess
import subprocess
p = subprocess.Popen(['ls', '-l'])
#p.communicate() #wait until done

endsnippet 

snippet init  "V7"
def __init__(self, pool, cr):
	super($1, self).__init__(pool, cr)
endsnippet

snippet init  "V9"
# besser _setup_fields verwenden als init; aber noch nicht getestet
@api.model
def _setup_fields(self, partial):
	super($1, self)._setup_fields(partial)
endsnippet


snippet pprint
from pprint import pprint 
with open('/tmp/data.txt', 'w') as f:
	pprint({0}, stream=f)
endsnippet

snippet send_mail "openerp no template, direct body"
url = self.pool['ir.config_parameter'].get_param(cr, uid, 'web.base.url')
url += "#model=" + self._name + "&id=" + str(id)

TODO nice insert here
            body.append(u'<a href="{}/mail/view?model={}&res_id={}">{}</a>'.format(
                self.env['ir.config_parameter'].get_param(key="web.base.url"),
                attached_to.ref._name,
                attached_to.ref.id,
                attached_to.ref.name_get()[0][1],
mail_id = self.pool["mail.mail"].create(cr, uid, {
	'auto_delete': True,
	'subject': subject,
	'body_html': "<a href='{}'>Open Directly</a>".format(url),
	'email_to': partner.email,
	${1:
	'model': "any model",
	'res_id': an int
	}
}, context=context)
self.pool["mail.mail"].send(cr, uid, [mail_id])
endsnippet

snippet send_mail "openerp from template by templatename"
#Send mail 
template_inst = self.pool['email.template'].search(cr, uid,[('name','=','${1:template_name}')]) 
if(template_inst): 
	self.pool['email.template'].send_mail(cr, uid, template_inst[0], id, False, context=context) 
else: 
	raise Exception("Email Template not Found: {}".format('${1}'))
${0}

endsnippet

snippet send_mail "openerp from template by xmlid V7"
templ_id = self.pool['ir.model.data'].get_object_reference(cr, uid, "${1:module}", "${2:xmlid}")[1]
self.pool['email.template'].send_mail(cr, uid, templ_id, ${3:id}, False, context=context) 
${0}

endsnippet

snippet send_mail "openerp from template by xmlid V8"
self.env['ir.model.data'].xmlid_to_object("${1:xmlid}").send_mail(${2:res_id}, force_send=False, raise_exception=True)
${0}

endsnippet

snippet open_line "add button to open record in one2many list"
def open_line(self, cr, uid, id, context=None):
	#in tree: 
	#<button name='open_line' icon='terp-folder-yellow' type='object'/>
	if isinstance(id, (int, long)):
		id = [id]
	me = self.browse(cr, uid, id[0], context=context)
	return {
		'type': 'ir.actions.act_window',
		'name': me.name,
		'view_type': 'form',
		'view_mode': 'form',
		'res_model': self._name,
		'res_id': id[0],
		'target': 'current',
	}
endsnippet

snippet env "with api.Environment.manage"
# try nicht unbedingt notwendig; bei __exit__ wird ein close aufgerufen
from odoo import registry
db_registry = registry(self.env.cr.dbname)
with api.Environment.manage(), db_registry.cursor() as cr:
	env = api.Environment(cr, SUPERUSER_ID, {})

endsnippet

snippet env "With Threading; send mail, when done"
def do_import(dbname, uid, nav5number):
	try:
		with api.Environment.manage():
			with registry(dbname).cursor() as cr:
				env = api.Environment(cr, uid, {})
				self2 = self.with_env(env)
				_except = False
				try:
					# Add the function here
					# rep_id = self2.env["mrp.heine.repair"].import_nav5(REPNumber=nav5number, filter_bom_to_current=self.filter_bom_to_current)
					body_html = self.env['mail.mail'].get_href('mrp.heine.repair', rep_id)
					${0}...
				except:
					body_html = traceback.format_exc()
					_except = True

				self2.env["mail.mail"].with_context(HREF_MODEL='mrp.heine.repair', HREF_RES_ID=rep_id).create({
					'auto_delete': True,
					'subject': "Repair {} {}".format(nav5number, 'imported' if not _except else 'error'),
					'body_html': body_html,
					'email_to': self2.env.user.effective_email,
				}).send()
	except:
		msg = traceback.format_exc()
		logger.error(msg)

t = threading.Thread(target=do_import, args=(self.env.cr.dbname, self.env.user.id, nav5number,))
t.daemon = True
t.start()
endsnippet


snippet barcode "Barcode as b64 to embedd in webkit/html"
from StringIO import StringIO
from barcode.writer import ImageWriter
code = barcode.get('code39', 'mar', writer=ImageWriter())
io = StringIO()
code.write(io)
io.seek(0)
import base64
code = base64.b64encode(io.read())

endsnippet

snippet copy
def copy(self, cr, uid, id, default=None, context=None):
	if default is None:
		default = {}
	default[''] = ...
	return super(${1:clazz}, self).copy(cr, uid, id, default, context)
endsnippet

snippet copy "copy V8"
@api.multi
def copy(self, default=None)
	return super(${1:clazz}, self).copy(default=default)
endsnippet

snippet c=n
context=None
endsnippet

snippet config "V7"
v = self.pool['ir.config_parameter'].get_param(cr, uid, key="${1}", default=${2:False}, context=context)
${0}
endsnippet

snippet config "V9"
v = self.env['ir.config_parameter'].get_param(key="${1}", default=${2:False})
${0}
endsnippet

snippet kivy_imports
from kivy.app import App
from kivy.uix.widget import Widget
from kivy.properties import NumericProperty, ReferenceListProperty, ObjectProperty
from kivy.vector import Vector
from kivy.clock import Clock
from random import randint
endsnippet

snippet message_post "V9: override"
@api.cr_uid_ids_context
@api.returns('mail.message', lambda value: value.id)
def message_post(self, cr, uid, thread_id, context=None, **kwargs):
	if isinstance(thread_id, basestring):
		thread_id = get_real_ids(thread_id)
	if context.get('default_date'):
		del context['default_date']
	return super(calendar_event, self).message_post(cr, uid, thread_id, context=context, **kwargs)
endsnippet

snippet message_post "Message Post Cases"
"""
     - ``mail_create_nosubscribe``: at create or message_post, do not subscribe
       uid to the record thread
     - ``mail_create_nolog``: at create, do not log the automatic '<Document>
       created' message
     - ``mail_notrack``: at create and write, do not perform the value tracking
       creating messages
     - ``tracking_disable``: at create and write, perform no MailThread features
       (auto subscription, tracking, post, ...)
     - ``mail_save_message_last_post``: at message_post, update message_last_post
       datetime field
     - ``mail_auto_delete``: auto delete mail notifications; True by default
       (technical hack for templates)
     - ``mail_notify_force_send``: if less than 50 email notifications to send,
       send them directly instead of using the queue; True by default
     - ``mail_notify_user_signature``: add the current user signature in
       email notifications; True by default
"""
self.message_post(subtype_id=self.env.ref("mail.mt_note'), body='${0}')
self.with_context(mail_message_post(subtype_id=self.env.ref("mail.mt_note'), body='${0}')

# message_post "Message to default followers"
self.message_post(cr, uid, [id], body='${0}', ${1:subtype='${2:xmlid}'}, )
# message_post "Message to certain partners (partner_ids ist in **kwargs in message_post enthalten)"
self.message_post(cr, uid, [id], body='${0}', ${1:subtype='${2:xmlid}'}, partner_ids=[(6,0, partner_ids)])
endsnippet

snippet field_states
'Field_name': fields.char('String'', readonly=False, states={'Done': [('readonly', True)]}
endsnippet

snippet action_client_reload
return {
	'type': 'ir.actions.client',
	'tag': 'reload'
}
endsnippet

snippet action_client_reload
#needs module web_actions
#return {'type':  'ir.actions.act_close_wizard_and_refresh_view'}
return {'type': 'ir.actions.client', 'tag': 'quick_reload'}
endsnippet

snippet index

def init(self, cr):
	cr.execute("SELECT indexname FROM pg_indexes WHERE indexname = '${1:indexname}'")
	if not cr.fetchone():
		cr.execute("""
			CREATE UNIQUE INDEX $1
			ON ${2:table} (${3:field})
		""")
endsnippet

snippet autobahn "imports mit twisted"
from twisted.internet import reactor
from twisted.python import log
from twisted.web.server import Site
from twisted.web.static import File

from autobahn.twisted.websocket import WebSocketServerFactory, WebSocketServerProtocol, listenWS

endsnippet

snippet autobahn "start reactor from __main__"
if __name__ == '__main__':

	ServerFactory = ${1:BroadcastServerFactory}
	debug = False

	factory = ServerFactory("ws://localhost:${2:9000}", debug = debug, debugCodePaths = debug)
	factory.protocol = ${3:BroadcastServerProtocol}
	factory.setProtocolOptions(allowHixie76 = True)
	listenWS(factory)

	webdir = File(".")
	web = Site(webdir)
	reactor.listenTCP(${4:8081}, web)
	reactor.run()

endsnippet

snippet autobahn ""
class ${1:Broadcast}ServerProtocol(WebSocketServerProtocol):

	def onOpen(self):
		self.factory.register(self)

	def onMessage(self, payload, isBinary):
		if not isBinary:
			payload = payload.decode('utf8')
			self.factory.onMessage(payload)

	def connectionLost(self, reason):
		WebSocketServerProtocol.connectionLost(self, reason)
		self.factory.unregister(self)


class $1ServerFactory(WebSocketServerFactory):
	def __init__(self, url, debug = False, debugCodePaths = False):
		WebSocketServerFactory.__init__(self, url, debug = debug, debugCodePaths = debugCodePaths)
		self.clients = []
		self.tickcount = 0
		self.dev = 0
		self.sleeptime = 1
		self.tick()

	def onMessage(self, msg):
		if msg == 'message1':
			pass
		elif msg == 'message2':
			pass

	def tick(self):
		self.broadcast('any text which is broadcasted')
		reactor.callLater(0.01, self.tick)

	def register(self, client):
		if not client in self.clients:
			self.clients.append(client)

	def unregister(self, client):
		if client in self.clients:
			self.clients.remove(client)

	def broadcast(self, msg):
		for c in self.clients:
			c.sendMessage(msg.encode('utf8'))

endsnippet

snippet try_until_key
try:
	$0
except KeyboardInterrupt:
	pass
endsnippet

snippet dt
from datetime import datetime
endsnippet

snippet workflow
wf_service = netsvc.LocalService("workflow")
wf_service.trg_validate(uid, '${1:model}', ${2:id}, '${3:signal}', cr)
wf_service.trg_create(uid, '${1:model}', ${2:id}, cr)
wf_service.trg_write(uid, '${1:model}', ${2:id}, cr)
wf_service.trg_trigger(uid, '${1:model}', ${2:id}, cr)
wf_service.trg_redirect(....)

record.signal_workflow('....')
endsnippet

snippet exists_process
def exists_process(part):
	import psutil
	ids = psutil.get_pid_list()
	for id in ids:
		print id
		with open('/proc/{}/cmdline'.format(id), 'r') as f:
			line = f.read()
			if part in line:
				return True
	return False

endsnippet

snippet wrap
def ${1:attribute_name}(method):
	def wrapper(*args, **kwargs):
		result = method(*args, **kwargs)
		$0
		return result
	return wrapper
endsnippet

snippet odoowebsite "Controller"
# -*- coding: utf-8 -*-
from openerp import http
from openerp.http import request
from openerp.addons.web.controllers.main import content_disposition
import base64


class Academy(http.Controller):
	@http.route('/downloads/<int:id>', auth='public', website=True)
	def index(self, id):
		p = request.registry.get("product.product").browse(
			request.cr, request.uid, id)

		return http.request.render("website_sale_download.index", {
			'product': p,
		})

	@http.route('/download/<guid>', auth='public', website=True)
	def download_file(self, guid):
		id = request.registry.get("ir.attachment").search(
			request.cr, request.uid, [('guid', '=', guid)])[0]
		attachment = request.registry.get("ir.attachment").read(
			request.cr, request.uid, id, ['name', 'datas'])[0]

		content = base64.b64decode(attachment['datas'])

		return http.request.make_response(content, [
			('Content-Type', 'application/octet-stream; charset=binary'),
			('Content-Disposition', content_disposition(attachment['name']))
		])
endsnippet

snippet spg8
request.registry.get("$1")$0
endsnippet

snippet reroute
request.registry['ir.http'].reroute(first_menu.url)
endsnippet

snippet stock_move
sm_id = self.pool["stock.move"].create(cr, uid, {
	"company_id": company_id,
	"date": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
	"date_expected": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
	"location_dest_id": fillial_stock_location_id,
	"location_id": customer_location_id,
	"name": name,
	"product_id": line.product_id.id,
	"product_uom": line.product_id.uom_id.id,
	"product_qty": qty,
	"state": "draft",
	"purchase_order_id": po_id,
	"purchase_line_id": line.id,
	"prodlot_id": prodlot_id
	}, context=context)
self.pool["stock.move"].write(cr, uid, [sm_id], {"state": "confirmed"})
self.pool["stock.move"].write(cr, uid, [sm_id], {"state": "assigned"})
self.pool["stock.move"].write(cr, uid, [sm_id], {"state": "done"})
cr.execute("update stock_move set origin = %s where id =%s", (order["data"]["name"], sm_id))
endsnippet

snippet needaction "Inherit"
_inherit = ['ir.needaction_mixin']
endsnippet

snippet has_group
self.pool['res.users'].has_group(cr, uid, '${1:group_xml_id}')
endsnippet

snippet search
def search(self, cr, user, args, offset=0, limit=None, order=None, context=None, count=False):
	${0}
	result = super(${clazz}, self).search(cr, user, args, offset=offset, limit=limit, order=order, context=context, count=count)
	return result
endsnippet

snippet read "V7"
def read(self, cr, uid, ids, fields=None, context=None, load='_classic_read'):
    result = super($1, self).read(cr, uid, ids, fields=fields, context=context, load=load)
endsnippet

snippet read "V9"
@api.multi # not working by that; list returned
def read(self, fields=None, load='_classic_read'):
	result = super($1, self).read(fields=fields, load=load)
endsnippet

snippet baseurl
baseurl = self.pool['ir.config_parameter'].get_param(cr, uid, 'web.base.url')
endsnippet

snippet exchange_report
report_sxw.report_sxw._services.pop("report.stock.picking.list")
report_sxw.report_sxw('report.stock.picking.list', 'stock.picking', parser=lieferschein)
endsnippet

snippet import "OSV 8.0 Style"
import openerp
from openerp import tools, api
from openerp.osv import osv, fields
from openerp.osv.expression import get_unaccent_wrapper
from openerp.tools.translate import _
import openerp.addons.decimal_precision as dp
import logging
logger = logging.getLogger(__name__)
endsnippet

snippet auto_init
def _auto_init(self, cr, context=None):
	super(${clazz}, self)._auto_init(cr, context)
	index_name = "{1:index_name}"
	cr.execute("SELECT indexname FROM pg_indexes WHERE indexname = '$1'")
	if not cr.fetchone():
		cr.execute('CREATE INDEX $1 ON ${2:table} (${3:columns})')

endsnippet

snippet auto_init "add column no error"
    def _auto_init(self, cr, context=None):
        result = super(res_users, self)._auto_init(cr, context)
        cr.execute('''
            DO $$
            BEGIN
                BEGIN
                    ALTER TABLE res_users add COLUMN signature varchar(255);
                EXCEPTION
                    WHEN duplicate_column THEN RAISE NOTICE 'ignore';
                END;
            END;
        $$
        ''')
        return result
endsnippet

snippet exc_import
from openerp.exceptions import UserError, RedirectWarning, ValidationError
endsnippet

snippet exc_redirect
raise RedirectWarning(msg, action.id, _('Go to the configuration panel'))
endsnippet

snippet model "new"
from odoo import _, api, fields, models, SUPERUSER_ID
from odoo.exceptions import UserError, RedirectWarning, ValidationError
class $1(models.Model):
	_name = '$2'
endsnippet

snippet model "inherit"
from odoo import _, api, fields, models, SUPERUSER_ID
from odoo.exceptions import UserError, RedirectWarning, ValidationError
class $1(models.Model):
	_inherit = '$2'

endsnippet

snippet setup_fields
@api.model
def _setup_fields(self, *args, **kwargs):
	super(${1:klass}, self)._setup_fields(*args, **kwargs)
	self._fields['....'].required = False
endsnippet

snippet property
company_dependent=True
endsnippet

snippet mailcompose "with template"
try:
	compose_form_id = ir_model_data.get_object_reference(cr, uid, 'mail', 'email_compose_message_wizard_form')[1]
except ValueError:
	compose_form_id = False
ctx.update({
	'default_model': 'account.invoice',
	'default_res_id': ids[0],
	'default_use_template': bool(template_id),
	'default_template_id': template_id,
	'default_composition_mode': 'comment',
	'mark_invoice_as_sent': True,
	})
return {
	'type': 'ir.actions.act_window',
	'view_type': 'form',
	'view_mode': 'form',
	'res_model': 'mail.compose.message',
	'views': [(compose_form_id, 'form')],
	'view_id': compose_form_id,
	'target': 'new',
	'context': ctx,
}
endsnippet

snippet route
@http.route('${1:path}', auth='${2:user}${3:public}'${4:, website=True}${5:, type='json'})
def ${1/[\.\/]/_/g}(self):
	$0
endsnippet

snippet ormcache
@tools.ormcache('param1', 'param2')
def doit(self, param1, param2):

zum loeschen (approbiert mit V9 05.01.2018)
self.env['model'].method.clear_cache(self)

@tools.ormcache(skiparg=1)  # noch nicht sicher ob 0 oder 1
def doit(self, param1, param2):

@api.one  (evtl. auch multi)
@tools.ormcache('self')

@api.model
@tools.ormcache('self._uid')
def context_get(self):
    .....

endsnippet


snippet contrains "V8 unique name"
@api.one
@api.constrains("${1:name}")
def _check_name(self):
	if self.search([('$1', '=', self.name), ('id', '!=', self.id)]):
		raise ValidationError("$1 must be unique!")
endsnippet

snippet redis
import redis
from redis import StrictRedis
conn = StrictRedis()
conn.set('test', 'value')
conn.rpush("anton", 4)
print conn.blpop('anton')
print conn.lrange('anton', 0, -1)
endsnippet

snippet excepthook
def myexcepthook(exctype, value, traceback):
    if exctype == KeyboardInterrupt:
        print "Handler code goes here"
    else:
        sys.__excepthook__(exctype, value, traceback)
sys.excepthook = myexcepthook
endsnippet

snippet slug
from openerp.addons.module_tools.other import slug
endsnippet

snippet datetools
from openerp.addons.module_tools import str2date, datetime2str, date_in_range
endsnippet

snippet fS "selection relate wrapper"
def _get_order_selection(self, *args, **kwargs):
	return self.env['sale.order']._fields['state'].selection
order_state = fields.Selection(related='order_id.state', store=False, selection=lambda self, *args, **kwargs: self._get_order_selection(*args, **kwargs))
endsnippet

snippet field_default_user
user_id = fields.Many2one('res.users', string='User', default=lambda self: self.env.user)
endsnippet

snippet res.lang.format
dt = fields.Datetime.now()
langs = self.env['res.lang'].search([('code', '=', self.env.user.lang)])
format_date = langs["date_format"]
format_time = langs["time_format"]

def do_format_date(dt):
	if not dt:
		return ''
	return self.format_tz(dt, tz=self.env.user.tz, format=format_date)

def do_format_currency(value):
	if not value:
		return ''
	return langs.format('%.2f', value, grouping=True, monetary=True)
endsnippet

snippet redirect "controller redirect V9"
import werkzeug
from werkzeug import url_encode

@http.route('/mail/follow', type='http', auth='user', methods=['GET'])
def mail_action_follow(self,  model, res_id, token=None):
	messaging_action = request.env['mail.thread']._get_inbox_action_xml_id()
	url = '/web#%s' % url_encode({'action': messaging_action})
	return werkzeug.utils.redirect(url)


@classmethod
def _redirect_to_record(cls, model, res_id):
	uid = request.session.uid
	url_params = {
		'view_type': record_action['view_type'],
		'model': model,
		'id': res_id,
		'active_id': res_id,
		'view_id': record_sudo.get_formview_id(),
		'action': record_action.get('id'),
	}
	url = '/web?#%s' % url_encode(url_params)
	return werkzeug.utils.redirect(url)
endsnippet

snippet does_pool_init
(not self.pool._init or getattr(threading.currentThread(), 'testing', False)):
endsnippet

snippet testing
getattr(threading.currentThread(), 'testing', False)
endsnippet

snippet message_subscribe
thread_document.message_subscribe([user.partner_id.id], channel_ids)
thread_document.message_subscribe_users(user_ids)
endsnippet

snippet url_action
return {
	'type': 'ir.actions.act_url',
	#'url': 'http://www.mut.de',
	'url': '/web/content/{}?download=True'.format(self.attachment_ids[0].id),
	'target': 'self'
}

# remarks: self instead of current, then it worked
endsnippet


snippet float
from openerp.tools.float_utils import float_is_zero, float_compare
endsnippet

snippet module_resource
img_path = openerp.modules.get_module_resource('base', 'static/src/img', 'money.png')
endsnippet


snippet unittest "create user"

self.${1:username} = self.env['res.users'].create({
	'login': '{}'.format(uuid.uuid4()),
	'notify_email': 'none',
	'name': 'unittest mail manager',
	'password': '1',
	'company_ids': [[6, 0, self.env.user.company_id.ids]],
	'company_id': self.env.user.company_id.id,
	'groups_id': [[6, 0, [
		self.ref("base.group_user"),
		self.ref('project.group_project_manager'),
		self.ref("mail_boxes.group_mail_manager"),
		self.ref('mail_hold_until_ok.group_can_release_mails'),
		self.ref('base.group_sale_manager'),
	]]],
})
self.$1.partner_id.email = '{}@test.de'.format(uuid.uuid4())
endsnippet

snippet migration
# 1. version in __openerp__.py hochziehen!
# 2. dir: migrations/9.0.1.1/pre-migration.py or post-migration.py
	Verzeichnisname traegt Zielversion

"""
        This class manage the migration of modules
        Migrations files must be python files containing a "migrate(cr, installed_version)"
        function. Theses files must respect a directory tree structure: A 'migrations' folder
        which containt a folder by version. Version can be 'module' version or 'server.module'
        version (in this case, the files will only be processed by this version of the server).
        Python file names must start by `pre` or `post` and will be executed, respectively,
        before and after the module initialisation. `end` scripts are run after all modules have
        been updated.

	Example:

		<moduledir>
		-- migrations
			|-- 1.0
			|   |-- pre-update_table_x.py
			|   |-- pre-update_table_y.py
			|   |-- post-create_plop_records.py
			|   |-- end-cleanup.py
			|   -- README.txt                      # not processed
			|-- 9.0.1.1                             # processed only on a 9.0 server
			|   |-- pre-delete_table_z.py
			|   `-- post-clean-data.py
			-- foo.py                              # not processed

"""


from odoo import api, SUPERUSER_ID

def migrate(cr, version):
    env = api.Environment(cr, SUPERUSER_ID, {})


endsnippet

snippet float_round
price = tools.float_round(price, precision_rounding=rule.price_round)
endsnippet


snippet unittest "accounts income, expense, receivable, payable, customer, supplier, accounts, product"
account_payable = self.env['account.account'].create({
	'code': uuid.uuid1().hex,
	'name': uuid.uuid1().hex,
	'user_type_id': self.env['ir.model.data'].xmlid_to_res_id('account.data_account_type_payable'),
	'reconcile': True,
})
account_receivable = self.env['account.account'].create({
	'code': uuid.uuid1().hex,
	'name': uuid.uuid1().hex,
	'user_type_id': self.env['ir.model.data'].xmlid_to_res_id('account.data_account_type_receivable'),
	'reconcile': True,
})
account_expense = self.env['account.account'].create({
	'code': uuid.uuid1().hex,
	'name': uuid.uuid1().hex,
	'type': 'expense',
	'user_type_id': self.env['ir.model.data'].xmlid_to_res_id('account.data_account_type_expense'),
})
account_income = self.env['account.account'].create({
	'code': uuid.uuid1().hex,
	'name': uuid.uuid1().hex,
	'type': 'income',
	'user_type_id': self.env['ir.model.data'].xmlid_to_res_id('account.data_account_type_other_income'),
})

self.assertEqual(account_receivable.internal_type, 'receivable')
self.assertEqual(account_payable.internal_type, 'payable')

customer = self.env['res.partner'].create({
	'name': 'supplier1',
	'account_receivable_id': account_receivable.id,
})

supplier = self.env['res.partner'].create({
	'name': 'supplier1',
	'account_payable_id': account_payable.id,
})

product = self.env['product.product'].create({
	'name': 'some product',
	'property_account_income_id': account_income.id,
	'property_account_expense_id': account_expense.id,
})

out_invoice = self.env['account.invoice'].create({
	'partner_id': customer.id,
	'number': uuid.uuid1().hex,
	'account_id': account_receivable.id,
	'payment_term_id': self.env['account.payment.term'].search([], limit=1).id,
	'type': 'out_invoice',
	'invoice_line_ids': [
		[0, 0, {
			'name': uuid.uuid1().hex,
			'product_id': product.id,
			'account_id': account_income.id,
			'price_unit': 100.0,
			'quantity': 1,
		}],
	],
})

in_invoice = self.env['account.invoice'].create({
	'partner_id': supplier.id,
	'account_id': account_payable.id,
	'number': uuid.uuid1().hex,
	'payment_term_id': self.env['account.payment.term'].search([], limit=1).id,
	'type': 'in_invoice',
	'invoice_line_ids': [
		[0, 0, {
			'name': uuid.uuid1().hex,
			'product_id': product.id,
			'account_id': account_expense.id,
			'price_unit': 100.0,
			'quantity': 1,
		}],
	],
})

payment_data = {
	'invoice_ids': [[6, 0, in_invoice.ids]],
	'payment_reference': in_invoice.number,
	'payment_date': fields.Datetime.now(),
	'communication': in_invoice.number,
	'payment_difference_handling': 'open',
	'journal_id': self.env['account.journal'].search([('bank_account_id', '!=', False), ('company_id', '=', self.env.user.company_id.id)], limit=1).id,
	'currency_id': in_invoice.currency_id.id,
	'partner_type': 'supplier',
	'amount': 80.0,
	'writeoff_account_id': False,
	'payment_type': 'outbound',
	'partner_id': in_invoice.partner_id.id,
}
if 'payment_method_id' in self.env['account.payment']._fields:
	payment_data['payment_method_id'] = self.env['account.payment.method'].search([], limit=1).id

payment_data['amount'] = 80
payment = self.env['account.payment'].create(payment_data)
payment.post()
self.assertEqual(in_invoice.state, 'open')
endsnippet

snippet recompute
self._recompute_todo(self._fields['${1: field}'])
self.recompute()
endsnippet

snippet env "env with no recompute"
with recs.env.norecompute():
	$0
endsnippet


snippet api_return_self
@api.returns('self', lambda value: value.id)
endsnippet

snippet unittest "TransactionCase"
from openerp.tests import common
common.TransactionCase
endsnippet

snippet report "Pivot"

# -*- coding: utf-8 -*-
# Part of Odoo. See LICENSE file for full copyright and licensing details.

from openerp import fields, models
from openerp import tools


class messages_times_report(models.Model):
    _name = "project.notes_with_time.report"
    _auto = False
    _rec_name = 'id'

    date = fields.Datetime('Date', readonly=True)
    account_id = fields.Many2one('account.analytic.account', string="Account", readonly=True)
    # author_id = fields.Many2one('res.partner', 'Author', readonly=True)
    # user_id = fields.Many2one('res.users', 'Responsible', readonly=True)
    # team_id = fields.Many2one('crm.team', 'Sales Team', readonly=True)
    # subtype_id = fields.Many2one('mail.message.subtype', 'Activity', readonly=True)
    # country_id = fields.Many2one('res.country', 'Country', readonly=True)
    # company_id = fields.Many2one('res.company', 'Company', readonly=True)
    # stage_id = fields.Many2one('crm.stage', 'Stage', readonly=True)
    #partner_id = fields.Many2one('res.partner', 'Partner/Customer', readonly=True)
    unit_amount = fields.Float("Hours")

    def init(self, cr):
        tools.drop_view_if_exists(cr, 'project_notes_with_time_report')
        cr.execute("""
            CREATE OR REPLACE VIEW project_notes_with_time_report AS (
                select
                    m.id,
                    m.date,
                    l.account_id,
                    l.unit_amount / 60.0
                from
                    "account_analytic_line" l
                inner join
                    "mail_message" m
                on
                    m.account_analytic_line_id = l.id
                WHERE
                    m.account_analytic_line_id is not null
            )""")
endsnippet

snippet pre_init_hook
'pre_init_hook': 'hook_pre_init',
'post_init_hook': 'hook_post_init',

def hook_pre_init(cr):  # in __init__.py

def post_init_hook(cr, reg):
    Environment.reset()
    env = Environment(cr, 1, context={})
    # env['ir.attachment'].search([])._get_filesize_char()
endsnippet

snippet controller "download pdf concated reports"
@http.route('/newsletter/make_pdf', auth='user', website=True, type='http')
def get_complete_pdf(self, *params, **kwparams):
	nl_id = request.httprequest.args.get('nl_id')
	recipient_id = request.httprequest.args.get('recipient_id')

	nl = request.env['crm.newsletter'].browse(nl_id)
	recipient = request.env['crm.newsletter.subject.recipient'].browse(recipient_id)

	files = []
	filepath = tempfile.mktemp()
	for report in nl.report_ids:
		if recipient.computed_partner_id:
			result_binary, format = self.env['ir.actions.report.xml'].render_report(recipient.computed_partner_id.ids, report.report_name, data={})
			filepath = tempfile.mktemp()
			with open(filepath, 'w') as f: f.write(result_binary)
			files.append(filepath)

	os.system("pdftk {} cat output {}".format(
		" ".join(files),
		filepath
	))
	with open(filepath) as f:
		content = f.read()

	return http.request.make_response(content, [
			('Content-Type', 'application/octet-stream; charset=binary'),
			('Content-Disposition', content_disposition("{}-{}.pdf".format(nl_id, recipient_id)))
	])
endsnippet

snippet monkeypatch "<=V10"

# use add magic fields for fields that are used in views like attachment_ids
origin = {
    '_add_magic_fields': models.BaseModel._add_magic_fields
}

def _add_magic_fields(self):
    origin['_add_magic_fields'](self)
    #dir = os.path.dirname(os.path.abspath(inspect.getfile(inspect.currentframe()))) # script directory
    module_name = get_resource_from_path(dir)[0]
    self.env.cr.execute("select state from ir_module_module where name =%s", (module_name,))
    state = self.env.cr.fetchone()
    if state:
        state = state[0]

    if state != 'installed':
        return

	if 'doc_count' not in self._fields:
		self._add_field('field_name', fields2.Integer(compute=_get_attachments, string="Count Documents"))


models.BaseModel._add_magic_fields = _add_magic_fields

def make_$1():

	@api.model
	def $1(self, name='', args=None, operator='ilike', limit=100):
		res = $1.origin(self, name=name, args=args, operator=operator, limit=limit)
		return res
	return $1

class ModelExtended(models.Model):
    _inherit = 'ir.model'

    def _register_hook(self, cr, ids=None):

        if ids is None:
            ids = self.search(cr, SUPERUSER_ID, [])
        for model in self.browse(cr, SUPERUSER_ID, ids):
            m = self.pool.get(model.model, False)
			if not m:
				continue
			m._patch_method('$1', make_$1())

			# add a field
			# for fields in views use _add_magic_fields
			#if 'doc_count' not in m._fields:
			#	m._add_field(cr, SUPERUSER_ID, 'doc_count', fields2.Integer(compute=_get_attachments, string="Count Documents"))
			#m._setup_fields(cr, SUPERUSER_ID, False)
			#m._setup_complete(cr, SUPERUSER_ID)

        return super(ModelExtended, self)._register_hook(cr, ids=ids)
endsnippet

snippet monkey_patch "patch instead of override method of class (computed fields e.g.)"
def make_$1():

	@api.model
	def $1(self):
		res = $1.origin(self)
		return res
	return $1

    def _register_hook(self, cr):
		super($class, self)._register_hook(cr)
		m._patch_method('$1', make_$1())
endsnippet

snippet monkeypatch "V11"

# use add magic fields for fields that are used in views like attachment_ids

def make_$1():

	@api.model
	def $1(self, name='', args=None, operator='ilike', limit=100):
		res = $1.origin(self, name=name, args=args, operator=operator, limit=limit)
		return res
	return $1


METHODEN HINZUFUEGEN evtl. so und ueberschreiben
class Base(models.AbstractModel):

    _inherit = 'base'

    @api.model
    def suspend_security(self):
        return self.sudo(user=BaseSuspendSecurityUid(self.env.uid))

	def _add_magic_fields(self):
		super()._add_magic_fields()
		if 'doc_count' not in self._fields:
			self._add_field('field_name', fields2.Integer(compute=_get_attachments, string="Count Documents"))


class ModelExtended(models.Model):
    _inherit = 'ir.model'

    @api.model_cr
    def _register_hook(self):

        if not self:
		    self = self.search([])
        for model in self:
            m = self.env.get(model.model, None)
			if m is None:
				continue
			m._patch_method('$1', make_$1())

        return super()._register_hook()
endsnippet

snippet build_model
@classmethod
def _build_model(cls, pool, cr):
	model = super(User, cls)._build_model(pool, cr)
	ModelCls = type(model)
	ModelCls.SELF_WRITEABLE_FIELDS += ['sipaccount_originate_id']
	return model
endsnippet

snippet check_if_comment_on_wall
if self.subtype_id != self.env.ref('mail.mt_note') and \
endsnippet

snippet mail_activity
self.env['mail.activity'].create({
	'summary': {1:heading},
	'note': {2:your_text},
	'activity_type_id': False,
	'activity_category': 'default',
	'date_deadline': fields.Datetime.now(),
	'res_model_id': self.env['ir.model']._get('{3:model}').model,
	'res_id': {4:res_id},
	'user_id': self.env.user.id,
})
endsnippet

snippet ot
odoo_trace()
endsnippet

snippet invalidate_cache
self.invalidate_cache(fnames=[${1:'field1', 'field2'}], ids=None)
endsnippet

snippet stock.quant "stock.quant v11"
available_quantity = self.env['stock.quant']._get_available_quantity(self.product_id, self.location_id)
endsnippet


snippet cr_after
threaded_print = threading.Thread(target=self._print, args=())
        
db_registry = registry(dbname)
with api.Environment.manage(), db_registry.cursor() as cr:
	env = api.Environment(cr, SUPERUSER_ID, _context)
	env['mail.mail'].browse(email_ids).send()
def _print():
self._cr.after('commit', threaded_print.start)
endsnippet

snippet fields "One2many with domain at res_id res_model"
activity_ids = fields.One2many(
	'mail.activity', 'res_id', 'Activities',
	auto_join=True,
	groups="base.group_user",
	domain=lambda self: [('res_model', '=', self._name)])
endsnippet

snippet mute_logger
try:
	with self._cr.savepoint(), tools.mute_logger('odoo.sql_db'):
		variant.unlink()
# We catch all kind of exception to be sure that the operation doesn't fail.
except (psycopg2.Error, except_orm):
	variant.write({'active': False})
	pass
endsnippet

snippet safe_eval
from odoo.tools.safe_eval import safe_eval
endsnippet

snippet optimization
 self.env['res.partner'].with_context(prefetch_fields=False).mapped('name')  # fast

 with self.env.norecompute():
     for line in order.line ....
self.recompute()


#disable value tracking
record.with_context(mail_notrack=Ture)

#disable all mail features autosubscription, value tracking ...
record.with_context(tracking_disable=True)

endsnippet

snippet NewId
from odoo.models import NewId
endsnippet

snippet expression
from odoo.osv import expression

expression.AND([dom1, dom2])
endsnippet

snippet registry "registry descendants"
registry(self.env.cr.dbname).descendants(['suggestion.mixin'], '_inherit')
endsnippet

snippet profile
from odoo.tools.profiler import profile

@profile
endsnippet

snippet expression
from odoo.osv import expression
expression.OR
expression.AND
endsnippet
